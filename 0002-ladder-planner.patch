From e1a7d4f2a2d44b69b0d2c2a1b7d0a9e1c2d3e4f5 Mon Sep 17 00:00:00 2001
From: Cortex Dev <dev@cortex.local>
Date: Fri, 22 Aug 2025 12:01:00 +0000
Subject: [PATCH 2/4] Add LadderPlanner and planner interfaces (KG, Bandit,
 Orchestrator, TodoStore)

diff --git a/cortex/planner/__init__.py b/cortex/planner/__init__.py
new file mode 100644
index 0000000..5d3b2c1
--- /dev/null
+++ b/cortex/planner/__init__.py
@@ -0,0 +1,3 @@
+from .ladder import LadderPlanner
+
+__all__ = ["LadderPlanner"]
diff --git a/cortex/planner/interfaces.py b/cortex/planner/interfaces.py
new file mode 100644
index 0000000..f1c2d3e
--- /dev/null
+++ b/cortex/planner/interfaces.py
@@ -0,0 +1,56 @@
+from __future__ import annotations
+from typing import Protocol, Any, Dict, Optional
+
+
+class KG(Protocol):
+    def get_context_for_title(self, title: str) -> str: ...
+    def compute_energy_for_title(self, title: str) -> float: ...
+    def write_decision(self, tool: str, node_id: str, reward: float) -> None: ...
+    def estimate_metric_delta(self, title: str) -> float: ...
+
+
+class Bandit(Protocol):
+    def select_tool(self, context: Optional[Dict[str, Any]] = None) -> str: ...
+    def update(self, tool: str, reward: float) -> None: ...
+
+
+class EventBus(Protocol):
+    async def emit(self, kind: str, **kwargs) -> None: ...
+    def emit_sync(self, kind: str, **kwargs) -> None: ...
+
+
+class Orchestrator(Protocol):
+    event_bus: EventBus
+    async def execute_action(self, tool: str, todo: Any, context: str, shadow: bool = True) -> str: ...
+
+
+class TodoStore(Protocol):
+    def upsert(self, t: Any) -> None: ...
+    def get(self, todo_id: str) -> Any: ...
+    def children_of(self, todo_id: str): ...
diff --git a/cortex/planner/ladder.py b/cortex/planner/ladder.py
new file mode 100644
index 0000000..ab3c9de
--- /dev/null
+++ b/cortex/planner/ladder.py
@@ -0,0 +1,214 @@
+from __future__ import annotations
+from typing import List, Dict, Optional, Tuple
+from cortex.planner.interfaces import KG, Bandit, Orchestrator, TodoStore
+from cortex.todo.models import (
+    Todo,
+    LadderStage,
+    TodoStatus,
+    Evidence,
+    ExitCriteria,
+)
+
+
+class LadderPlanner:
+    """Implements LADDER: Localize → Assess → Decompose → Decide → Execute → Review."""
+
+    def __init__(self, kg: KG, bandit: Bandit, store: TodoStore, orchestrator: Orchestrator):
+        self.kg = kg
+        self.bandit = bandit
+        self.store = store
+        self.orch = orchestrator
+
+    async def plan_from_user_event(self, user_event) -> Todo:
+        """Entry point: create a root TODO and run LADDER stages."""
+        root = self._localize(user_event)
+        await self._emit("todo.created", root.id, {"title": root.title})
+        self.store.upsert(root)
+        await self._ladder(root)
+        return root
+
+    async def _ladder(self, root: Todo) -> None:
+        self._advance_stage(root, LadderStage.ASSESS)
+        self._assess(root)
+
+        self._advance_stage(root, LadderStage.DECOMPOSE)
+        children = self._decompose(root)
+
+        self._advance_stage(root, LadderStage.DECIDE)
+        self._decide(root, children)
+
+        self._advance_stage(root, LadderStage.EXECUTE)
+        await self._execute(root, children)
+
+        self._advance_stage(root, LadderStage.REVIEW)
+        await self._review(root, children)
+
+    # ===== L =====
+    def _localize(self, user_event) -> Todo:
+        title = user_event.payload.get("query", "user task")
+        desc = user_event.payload.get("context")
+        t = Todo(title=title, description=(desc or ""), stage=LadderStage.LOCALIZE)
+        t.exit_criteria.append(ExitCriteria(description="Measurable outcome defined"))
+        return t
+
+    # ===== A =====
+    def _assess(self, t: Todo) -> None:
+        ctx = self.kg.get_context_for_title(t.title)
+        energy = self.kg.compute_energy_for_title(t.title)
+        t.energy = float(energy)
+        t.confidence = min(1.0, 0.4 + 0.6 * float(energy))
+        if ctx:
+            t.description = (t.description or "") + f"\n\n[context]: {ctx[:1000]}"
+        self.store.upsert(t)
+        self._emit_sync("plan.assessed", t.id, {"energy": t.energy, "confidence": t.confidence})
+
+    # ===== D1 =====
+    def _decompose(self, root: Todo) -> List[Todo]:
+        """Create hierarchical subtasks and dependency edges (DAG)."""
+        subtasks_spec = [
+            ("Gather failure signals & logs", []),
+            ("Locate code regions & recent changes", ["Gather failure signals & logs"]),
+            ("Reproduce failing tests locally", ["Gather failure signals & logs"]),
+            ("Isolate root cause", ["Locate code regions & recent changes", "Reproduce failing tests locally"]),
+            ("Draft fix plan & validation steps", ["Isolate root cause"]),
+        ]
+
+        created: List[Todo] = []
+        name_to_id: Dict[str, str] = {}
+
+        for title, deps in subtasks_spec:
+            st = Todo(
+                title=title,
+                description=f"Subtask of {root.title}",
+                parent_id=root.id,
+                stage=LadderStage.DECIDE,  # children begin at D2
+            )
+            self.store.upsert(st)
+            root.children_ids.append(st.id)
+            name_to_id[title] = st.id
+            created.append(st)
+            self._emit_sync("todo.created", st.id, {"parent_id": root.id, "title": title})
+
+        # add dependencies
+        for title, deps in subtasks_spec:
+            st_id = name_to_id[title]
+            st = self.store.get(st_id)
+            for dep_name in deps:
+                st.depends_on.add(name_to_id[dep_name])
+            self.store.upsert(st)
+            if deps:
+                self._emit_sync("todo.linked", st.id, {"depends_on": [name_to_id[d] for d in deps]})
+
+        self.store.upsert(root)
+        self._emit_sync("plan.decomposed", root.id, {"children": root.children_ids})
+        return created
+
+    # ===== D2 =====
+    def _decide(self, root: Todo, children: List[Todo]) -> None:
+        topo_ready: List[Tuple[float, Todo]] = []
+        for st in children:
+            unmet = len([d for d in st.depends_on if self.store.get(d).status != TodoStatus.DONE])
+            base_energy = float(self.kg.compute_energy_for_title(st.title))
+            st.energy = base_energy
+            st.priority = self._priority_score(base_energy, unmet)
+            st.tool_hint = self.bandit.select_tool(context={"title": st.title, "energy": base_energy})
+            self.store.upsert(st)
+            topo_ready.append((st.priority, st))
+            self._emit_sync(
+                "plan.decided",
+                st.id,
+                {"priority": st.priority, "tool_hint": st.tool_hint, "unmet_deps": unmet},
+            )
+        topo_ready.sort(key=lambda x: x[0], reverse=True)
+        root.priority = topo_ready[0][0] if topo_ready else root.energy
+        self.store.upsert(root)
+
+    def _priority_score(self, energy: float, unmet_deps: int) -> float:
+        return energy * 0.8 + (1.0 / (1 + unmet_deps)) * 0.2
+
+    # ===== E =====
+    async def _execute(self, root: Todo, children: List[Todo]) -> None:
+        for st in sorted(children, key=lambda c: c.priority, reverse=True):
+            if any(self.store.get(d).status != TodoStatus.DONE for d in st.depends_on):
+                st.status = TodoStatus.BLOCKED
+                self.store.upsert(st)
+                continue
+            st.status = TodoStatus.IN_PROGRESS
+            self.store.upsert(st)
+
+            tool = st.tool_hint or self.bandit.select_tool(context={"title": st.title})
+            ctx = self.kg.get_context_for_title(st.title)
+            result = await self.orch.execute_action(tool, st, ctx, shadow=True)
+            st.evidence.append(Evidence(kind="log", summary=f"[SHADOW] tool={tool} result={str(result)[:200]}"))
+            st.status = TodoStatus.DONE  # Heuristic for shadow mode completion
+            self.store.upsert(st)
+            self._emit_sync("plan.executed", st.id, {"tool": tool, "shadow": True})
+
+    # ===== R =====
+    async def _review(self, root: Todo, children: List[Todo]) -> None:
+        total_reward = 0.0
+        for st in children:
+            proxy = 1.0 if st.status == TodoStatus.DONE else 0.0
+            evid = min(1.0, 0.2 * len(st.evidence))
+            delta = float(self.kg.estimate_metric_delta(st.title))
+            reward = 0.5 * proxy + 0.3 * evid + 0.2 * max(0.0, delta)
+            total_reward += reward
+
+            if st.tool_hint:
+                self.bandit.update(st.tool_hint, reward)
+            self.kg.write_decision(st.tool_hint or "unknown", st.id, reward)
+            self._emit_sync("plan.reviewed", st.id, {"reward": reward, "metric_delta": delta})
+
+        root.energy = float(self.kg.compute_energy_for_title(root.title))
+        root.priority = max((c.priority for c in children), default=root.energy)
+        root.status = TodoStatus.DONE
+        self.store.upsert(root)
+        await self._emit("plan.completed", root.id, {"aggregate_reward": total_reward})
+
+    # ----- helpers -----
+    def _advance_stage(self, t: Todo, stage: LadderStage) -> None:
+        t.stage = stage
+        self.store.upsert(t)
+        self._emit_sync("todo.stage_advanced", t.id, {"stage": stage.value})
+
+    async def _emit(self, kind: str, todo_id: Optional[str], payload: Dict) -> None:
+        await self.orch.event_bus.emit(kind, todo_id=todo_id, payload=payload)
+
+    def _emit_sync(self, kind: str, todo_id: Optional[str], payload: Dict) -> None:
+        self.orch.event_bus.emit_sync(kind, todo_id=todo_id, payload=payload)
--
2.45.0
