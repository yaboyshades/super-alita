From a1b2c3d4e5f60718293ab4cd5e6f708192a3bcde Mon Sep 17 00:00:00 2001
From: Cortex Dev <dev@cortex.local>
Date: Fri, 22 Aug 2025 13:00:00 +0000
Subject: [PATCH 5/8] Add config flags and complexity router; route complex
 events to LADDER planner

diff --git a/cortex/config/__init__.py b/cortex/config/__init__.py
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/cortex/config/__init__.py
@@ -0,0 +1 @@
+# Config package for feature flags and settings
diff --git a/cortex/config/flags.py b/cortex/config/flags.py
new file mode 100644
index 0000000..8f1a2c3
--- /dev/null
+++ b/cortex/config/flags.py
@@ -0,0 +1,62 @@
+from __future__ import annotations
+import os
+from dataclasses import dataclass
+
+
+def _env_bool(name: str, default: bool = False) -> bool:
+    v = os.getenv(name)
+    if v is None:
+        return default
+    return v.strip().lower() in {"1", "true", "yes", "on"}
+
+
+@dataclass(frozen=True)
+class PlannerFlags:
+    """Feature flags controlling planner behavior."""
+    use_ladder_router: bool = _env_bool("CORTEX_USE_LADDER_ROUTER", True)
+    ladder_llm_decompose: bool = _env_bool("CORTEX_LADDER_LLM_DECOMPOSE", False)
+    ladder_shadow_mode: bool = _env_bool("CORTEX_LADDER_SHADOW_MODE", True)
+
+
+FLAGS = PlannerFlags()
diff --git a/cortex/orchestrator/router.py b/cortex/orchestrator/router.py
new file mode 100644
index 0000000..c2d3e4f
--- /dev/null
+++ b/cortex/orchestrator/router.py
@@ -0,0 +1,98 @@
+from __future__ import annotations
+from typing import Dict, Any
+from cortex.config.flags import FLAGS
+from cortex.orchestrator.ladder_adapter import handle_user_event as ladder_handle
+
+
+def _complexity_score(query: str, context: str = "") -> float:
+    """
+    Lightweight heuristic to estimate task complexity.
+    Signals: length, presence of multi-step cues, uncertainty tokens, and error keywords.
+    """
+    q = (query or "").lower()
+    ctx = (context or "").lower()
+    tokens = q.split()
+    score = 0.0
+
+    if len(tokens) > 10:
+        score += 0.2
+    multi_step_markers = ["then", "after", "next", "pipeline", "stages", "steps", "regression", "deployment"]
+    if any(m in q for m in multi_step_markers):
+        score += 0.4
+    uncertainty = ["seems", "maybe", "not sure", "investigate"]
+    if any(u in q for u in uncertainty):
+        score += 0.1
+    errorish = ["error", "fail", "broken", "timeout", "flake"]
+    if any(e in q for e in errorish):
+        score += 0.2
+    if "recent" in q or "since" in q:
+        score += 0.1
+    if "login" in q and "deployment" in q:
+        score += 0.2
+    if any(k in ctx for k in ["incident", "alert", "rollback"]):
+        score += 0.1
+    return min(score, 1.0)
+
+
+async def route_user_event(kg, bandit, user_event, orchestrator=None) -> Dict[str, Any]:
+    """
+    Route a user event to the appropriate handler.
+    - If the complexity score is high and router is enabled, use LADDER planner.
+    - Otherwise, return a minimal plan suggestion (non-LADDER stub).
+    """
+    payload = getattr(user_event, "payload", {}) or {}
+    query = payload.get("query", "")
+    context = payload.get("context", "")
+    score = _complexity_score(query, context)
+
+    if FLAGS.use_ladder_router and score >= 0.5:
+        # Complex: go through the LADDER pipeline
+        return await ladder_handle(kg=kg, bandit=bandit, user_event=user_event, orchestrator=orchestrator)
+
+    # Simple: return a lightweight plan skeleton (no side effects)
+    return {
+        "mode": "simple",
+        "suggested_next_actions": [
+            {"title": "Search codebase for keywords", "reason": "quick triage"},
+            {"title": "Open related tests", "reason": "localize failure"},
+        ],
+        "complexity_score": score,
+    }
--
2.45.0
